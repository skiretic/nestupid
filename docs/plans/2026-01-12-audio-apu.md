# Audio (APU) Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement a cycle-accurate 2A03 APU to provide audio for *Super Mario Bros.* and other games.

**Architecture:** The APU will be implemented as a state machine in `src/apu.c`, driven by `apu_step()`. It will maintain internal state for 5 channels (Pulse 1, Pulse 2, Triangle, Noise, DMC) and a Frame Counter. Output will be generated by a Mixer function and fed to a ring buffer consumed by SDL2.

**Tech Stack:** C11, SDL2 Audio.

---

### Task 1: APU Skeleton & Data Structures

**Files:**
- Modify: `src/apu.h`
- Modify: `src/apu.c`
- Create: `tests/test_apu_basic.c`

**Step 1: Write the failing test**

```c
// tests/test_apu_basic.c
#include "../src/apu.h"
#include <assert.h>
#include <stdio.h>

int main() {
    apu_init();
    apu_reset();
    
    // Write to Pulse 1 Control (Duty, Envelope)
    apu_write_reg(0x4000, 0xBF); 
    // Verify register state (mock helper needed or check internal state if exposed/logged)
    // For now, we just ensure it doesn't crash and we can call step
    apu_step();
    
    printf("Basic APU test passed\n");
    return 0;
}
```

**Step 2: Run test to verify it fails**

Run: `gcc tests/test_apu_basic.c src/apu.c -o test_basic && ./test_basic`
Expected: Likely passes now but does nothing. We want to fail because structs aren't defined. (Actually C is loose, so it might pass, but we will define structs next).

**Step 3: Write minimal implementation**

Definition of structs in `apu.c` (internal) and `apu.h` (public interface remains simple).

```c
// src/apu.c
typedef struct {
    uint8_t enabled;
    uint8_t channel_1_enable;
    // ...
} APU_State;

static APU_State apu;
```

**Step 4: Run test to verify it passes**

Run: `gcc tests/test_apu_basic.c src/apu.c -o test_basic && ./test_basic`
Expected: PASS

**Step 5: Commit**

```bash
git add src/apu.c src/apu.h tests/test_apu_basic.c
git commit -m "feat(apu): add basic data structures and skeleton"
```

---

### Task 2: Pulse Channels (1 & 2)

**Files:**
- Modify: `src/apu.c`
- Modify: `tests/test_apu_basic.c`

**Step 1: Write the failing test**

Update `tests/test_apu_basic.c` to check for pulse timer values.

```c
    // Write Timer Low
    apu_write_reg(0x4002, 0xFD);
    // Write Timer High (and length counter load)
    apu_write_reg(0x4003, 0x00);
    
    // We expect the internal timer to be set (hard to verify without exposing state, 
    // so we might add a debug getter or just trust the logic for this plan step).
    // Better: apu_read_reg(0x4015) should show status if length counter > 0
```

**Step 2: Run test to verify it fails**

Run: `gcc ...`
Expected: FAIL (Status register not implemented)

**Step 3: Write minimal implementation**

Implement `write_pulse1`, `write_pulse2` logic for 0x4000-0x4007.
Implement Pulse struct: `timer`, `length_counter`, `duty`, `envelope`.

**Step 4: Run test to verify it passes**

Run: `gcc ...`
Expected: PASS

**Step 5: Commit**

```bash
git add src/apu.c
git commit -m "feat(apu): implement pulse channel registers"
```

---

### Task 3: Triangle Channel

**Files:**
- Modify: `src/apu.c`

**Step 1: Write the failing test**

Test writes to 0x4008, 0x400A, 0x400B.

**Step 3: Write minimal implementation**

Implement Triangle struct: `linear_counter`, `timer`, `length_counter`.
Implement logic for Linear Counter control.

**Step 5: Commit**

```bash
git commit -m "feat(apu): implement triangle channel"
```

---

### Task 4: Noise Channel

**Files:**
- Modify: `src/apu.c`

**Step 1: Write the failing test**

Test writes to 0x400C, 0x400E, 0x400F.

**Step 3: Write minimal implementation**

Implement Noise struct: `timer`, `length_counter`, `envelope`, `lfsr` (15-bit).
Implement LFSR feedback logic (Mode 0 vs Mode 1).

**Step 5: Commit**

```bash
git commit -m "feat(apu): implement noise channel"
```

---

### Task 5: Frame Counter & Status

**Files:**
- Modify: `src/apu.c`

**Step 1: Write the failing test**

Test 0x4017 writes (Mode 0/1).
Test 0x4015 reads (Status).

**Step 3: Write minimal implementation**

Implement `clock_frame_counter()`.
- Step 1: Clock Envelopes/Linear Counter
- Step 2: Clock Envelopes/Linear Counter + Length/Sweep
- ...

Implement 0x4015 status read (returning length counter > 0 status).

**Step 5: Commit**

```bash
git commit -m "feat(apu): implement frame counter and status register"
```

---

### Task 6: Mixer & Output Generation

**Files:**
- Modify: `src/apu.c`
- Modify: `src/apu.h`

**Step 1: Write the failing test**

Call `apu_get_sample()`. Expect non-zero if channels are enabled.

**Step 3: Write minimal implementation**

Implement `float apu_get_sample(void)`.
- Calculate `pulse_out`, `tnd_out`.
- Use the non-linear mixing formula:
  `output = pulse_out + tnd_out`
  `pulse_out = 95.88 / ((8128 / (pulse1 + pulse2)) + 100)`
  `tnd_out = 159.79 / ((1 / (triangle / 8227 + noise / 12241 + dmc / 22638)) + 100)`

**Step 5: Commit**

```bash
git commit -m "feat(apu): implement mixer"
```

---

### Task 7: SDL Integration

**Files:**
- Modify: `src/gui.c`
- Modify: `src/main.c`

**Step 1: Manual Test Plan**
- Run *Super Mario Bros.*
- Listen for audio.

**Step 3: Write minimal implementation**
- Initialize SDL Audio in `gui_init()`.
- Create a buffer/queue.
- In `main` loop, run `apu_step()` (roughly 1/3 of CPU cycles, or catch up).
- Push samples to SDL audio queue.

**Step 5: Commit**

```bash
git commit -m "feat(apu): integrate with SDL audio"
```
